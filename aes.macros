* This makes a function wrapper that is callable from C,
* taking a pointer to the state structure as its argument.
	macro
	CFunction &fn
	phb
	plx
	ply
	tdc
	pld
	plb
	plb
	phy
	phx
	plb
	pha
	jsl	&fn
	pld
	rtl
	mend


	macro
	ExpandKeyCore &xorback,&rconoffset

	ShortRegs
	
	ldy	rk-3,x
	lda	Sbox,y
	eor	Rcon-&xorback+&rconoffset,x
	eor	rk-&xorback,x
	sta	rk,x
	
	ldy	rk-2,x
	lda	Sbox,y
	eor	rk+1-&xorback,x
	sta	rk+1,x
	
	ldy	rk-1,x
	lda	Sbox,y
	eor	rk+2-&xorback,x
	sta	rk+2,x
	
	ldy	rk-4,x
	lda	Sbox,y
	eor	rk+3-&xorback,x
	sta	rk+3,x

	LongRegs

	mend

* Secondary substitution step used when expanding AES-256 keys
	macro
	ExpandKeySubst &xorback,&rconoffset

	ShortRegs
	
	ldy	rk-4,x
	lda	Sbox,y
	eor	rk-&xorback,x
	sta	rk,x
	
	ldy	rk+1-4,x
	lda	Sbox,y
	eor	rk+1-&xorback,x
	sta	rk+1,x
	
	ldy	rk+2-4,x
	lda	Sbox,y
	eor	rk+2-&xorback,x
	sta	rk+2,x
	
	ldy	rk+3-4,x
	lda	Sbox,y
	eor	rk+3-&xorback,x
	sta	rk+3,x

	LongRegs

	mend


	macro
	ExpandKeyIter &xorback,&nwords
	lcla	&i
	lda	rk,x
.loop1
	eor	rk+&i+4-&xorback,x
	sta	rk+&i+4,x
&i	seta	&i+4
	aif	&i/4<&nwords,.loop1

&i	seta	2
	lda	rk+2,x
.loop2
	eor	rk+&i+4-&xorback,x
	sta	rk+&i+4,x
&i	seta	&i+4
	aif	&i/4<&nwords,.loop2
	mend


	macro
	AddInitialRoundKey
	lcla	&i
.top
	lda	state1+&i
	eor	rk+&i
	sta	state1+&i
&i	seta	&i+2
	aif	&i<16,.top
	mend


	macro
&lbl	NormalRound &round
&lbl	anop
	aif	&round/2*2=&round,.evenround
	MixColumn 0,0,5,10,15,state1,state2
	MixColumn 4,4,9,14,3,state1,state2
	MixColumn 8,8,13,2,7,state1,state2
	MixColumn 12,12,1,6,11,state1,state2
	ago	.done
.evenround
	MixColumn 0,0,5,10,15,state2,state1
	MixColumn 4,4,9,14,3,state2,state1
	MixColumn 8,8,13,2,7,state2,state1
	MixColumn 12,12,1,6,11,state2,state1	
.done
	mend


	macro
	MixColumn &i,&A,&B,&C,&D,&state,&out

	aif	(&i=0).AND.(&round<>1),.skip
	ldy	&state+&D
.skip
	lda	Sbox,Y
	pha
	ldx	&state+&A
	eor	Xtime2Sbox,X
	ldy	&state+&B
	eor	Xtime3Sbox,Y
	ldy	&state+&C
	eor	Sbox,Y
	eor	rk+&round*16+&i
	sta	&out+&i

	pla
	eor	Xtime3Sbox,Y	
	eor	Sbox,X
	ldy	&state+&B
	eor	Xtime2Sbox,Y
	eor	rk+&round*16+&i+1
	sta	&out+&i+1

	lda	Sbox,Y
	pha
	ldy	&state+&D
	eor	Xtime3Sbox,Y
	eor	Sbox,X
	ldy	&state+&C
	eor	Xtime2Sbox,Y
	eor	rk+&round*16+&i+2
	sta	&out+&i+2

	pla
	eor	Sbox,Y
	eor	Xtime3Sbox,X
	ldy	&state+&D
	eor	Xtime2Sbox,Y
	aif	(rk+&round*16+&i+3)>255,.bigindex
	eor	rk+&round*16+&i+3
	ago	.cont
.bigindex
	ldx	#&round*16+&i+3
	eor	rk,X
.cont
	sta	&out+&i+3
	aif	&i<>12,.skip2
	tay
.skip2
	mend


	macro
	FinalRound &round

	FinalRoundStep 3,15,1
	FinalRoundStep 15,11
	FinalRoundStep 11,7
	FinalRoundStep 7,3

	FinalRoundStep 0,0
	FinalRoundStep 4,4
	FinalRoundStep 8,8
	FinalRoundStep 12,12

	FinalRoundStep 13,1
	FinalRoundStep 1,5
	FinalRoundStep 5,9
	FinalRoundStep 9,13

	FinalRoundStep 10,2
	FinalRoundStep 2,10
	FinalRoundStep 14,6
	FinalRoundStep 6,14
	
	mend


	macro
	FinalRoundStep &to,&from,&skipldy

	aif	C:&skipldy,.skip
	ldy	state2+&from
.skip
	lda	Sbox,Y
	aif	(rk+&round*16+&to)>255,.bigindex
	eor	rk+&round*16+&to
	ago	.cont
.bigindex
	ldx	#&round*16+&to
	eor	rk,X
.cont
	sta	state1+&to

	mend


	macro
	ShortRegs
	sep	#$30
	longa	off
	longi	off
	mend


	macro
	LongRegs
	rep	#$30
	longa	on
	longi	on
	mend

